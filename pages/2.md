[Top](../README.md)
# アルゴリズムとプログラミング
## データ構造
- スタック→深さ優先
- キュー→幅優先
- バランス木
  - AVL木：左右の部分木の高さの差が１以下
  - B木：葉に飲みデータを格納

## 探索
- 線形探索
  - $O(n)$
  - 番兵法：末尾に探索データを付けておくことで確実に終了させる
- ２分探索
  - $O(logn)$
- ハッシュ法 
  - $O(1)$
  - シノニム：衝突が起きてそこに格納できないデータのこと
  - シノニムの回避
    - オープンアドレス法：ハッシュ値＋１に格納してみて横にずらしていく
    - チェイン法：同じハッシュ値のものをリストでつなげる
      - $O(n/m)$ になる。$m$ ：ハッシュ表の大きさ
- 分割統治法
  - 全体をいくつかの小さな問題に分割、それぞれを独立に処理した結果をつなぎ合わせることで、全体の問題を解決する
- 分枝限定法
  - 枝刈りしていきながら解を限定していく
- 局所探索法
  - 全体の一部分に注目し、とりあえず粗い解を出してから逐次改良し、精度を上げていく
- 貪欲法
  - 全体のことは考えずに各時点で最良の選択をしていくことで、解を導く

## ソート
- 逐次添加法
  - バブルソート： $O(n^2)$
  - 単純選択法：未整列から最小を選んでくる $O(n^2)$
  - 単純挿入法：未整列の先頭を巻き込んでソートしていく $O(n^2)$
- 分割統治法
  - クイックソート： $O(nlogn)$
  - マージソート： $O(nlogn)$
- データ構造の利用
  - ヒープソート： $O(nlogn)$

## プログラミング言語
- 再使用可能
  - 初期化により、再ロードが不要
- 再配置可能
  - 適切なアドレッシングにより、どこに置いても正しく動作
- 再入可能
  - 複数のタスクから同時に呼び出し可能
  - データと手続きを分離することで実現